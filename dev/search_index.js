var documenterSearchIndex = {"docs":
[{"location":"wigner/wigner_single/#wigner_single","page":"Single system state","title":"Wigner quasiprobability of a single CV system state","text":"","category":"section"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"The Wigner quasiprobability representation of a single continuous-variable (CV) system's state rho is defined as","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"  W(xp)=frac1pihbarint_-infty^+infty \n  expleft(frac2ihbarpyright) \n  langle x-y vert rho vert x+yrangle \n  mathrmdy ","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"It is evident that this representation is defined by the Fourier transform of the antidiagonals of the density matrix rho expressed in the position basis. Since CVsim.jl relies on position or momentum representations of CV system states, we can obtain their Wigner quasiprobability through a fast Fourier transform of the columns of their \"skewed density matrix\". The latter corresponds to the original position density matrix but skewed along one direction,","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"  beginpmatrix\n  cdot  cdot  cdot  cdot \n  cdot  cdot  cdot  cdot \n  cdot  cdot  cdot  cdot \n  cdot  cdot  cdot  cdot \n  endpmatrix \n  mapsto\n  beginpmatrix\n  cdot  cdot  cdot  cdot  0  0  0 \n  0  cdot  cdot  cdot  cdot  0  0\n  0  0  cdot  cdot  cdot  cdot  0\n  0  0  0  cdot  cdot  cdot  cdot \nendpmatrix ","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"Note that the first, third, fifth, etc. columns will contain the desired antidiagonal elements. The even columns will contain in-between antidiagonals and hold mostly redundant information. They could be included but that requires extra computation due to how they straddle across the diagonal. Selecting the odd columns and performing their FFT gives us the desired Wigner quasi-probability as a square matrix of the same dimension as rho.","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"This calculation has been first implemented in Python by the Wikipedia user Nanite in their \"Long-time evolution of a mixed state ρ in an anharmonic  potential well.\" simulation. We adapted it in Julia here.","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"wignerify(::Matrix{ComplexF64})","category":"page"},{"location":"wigner/wigner_single/#CVsim.wignerify-Tuple{Matrix{ComplexF64}}","page":"Single system state","title":"CVsim.wignerify","text":"wignerify(mat)\n\nCompute the Wigner transform of position-basis density matrix which is  a Fourier transform of the anti-diagonals of the matrix (cf. Wikipedia).\n\nPad the matrix along one dimension, then skew the matrix. This converts the antidiagonals to straight columns.\n\n       |‾‾‾‾|          |‾‾‾‾000|\n       |    |    -->   |0    00|\n       |    |          |00    0|\n       |____|          |000____|\n\nNote that the first, third, fifth, etc. columns will contain the desired antidiagonal elements. The even columns will contain in-between antidiagonals. Here we are interested only in the former ones, i.e. the skew matrix is a square matrix of the same dimensions as the original density matrix in the  position basis.\n\nThis calculation has been first implemented in Python by the Wikipedia user  \"Nanite\" in their \"Long-time evolution of a mixed state ρ in an anharmonic  potential well.\" simulation and adapted in Julia here. src: https://en.wikipedia.org/wiki/File:Hamiltonianflowquantum.webm\n\nInputs:\n\nmat::Matrix{ComplexF64} : Matrix representing an operator (density                              matrix) in a position basis.\n\nOutput:\n\nMatrix{Float64}         : Wigner transform of the matrix                              (same shape as mat).\n\n\n\n\n\n","category":"method"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"In CVsim.jl, we overload this function to enable seamless integration with QuantumOptics.jl, specifically Operator objects (representing density matrices) and StateVector objects (encompassing Ket and Bra states), all defined in a position basis.","category":"page"},{"location":"wigner/wigner_single/","page":"Single system state","title":"Single system state","text":"wignerify(rho::Operator{B,B}) where B<:PositionBasis\nwignerify(psi::StateVector{B}) where B<:PositionBasis","category":"page"},{"location":"wigner/wigner_single/#CVsim.wignerify-Union{Tuple{Operator{B, B}}, Tuple{B}} where B<:PositionBasis","page":"Single system state","title":"CVsim.wignerify","text":"wignerify(rho)\nwignerify(rho,indices)\n\nCompute the Wigner quasiprobability distribution for the given operator rho.\n\nIf its basis B is a single position basis it returns a single distribution.\n\nIf instead B is a composite basis then it will calculate the Wigner quasiprobability distribution for all the subsystems which have a position basis.\n\nInputs:\n\nrho::Operator{B,B}        : Operator (density matrix) defined in                                the basis B\nindices::Vector{Int}      : Indices of the subspaces for which you                               would like a Wigner quasiprobability\n\nOutput:\n\nif B == PositionBasis:\nMatrix{Float64}         : Wigner quasiprobability of dimension n = length(B)\nif B == CompositeBasis or if indices are specified:\nVector{Matrix{Float64}} : Vector with Wigner quasiprobability of                             dimension n_k = length(B_k) where B_k                             is the position basis of a subspace of B\n\n\n\n\n\n","category":"method"},{"location":"wigner/wigner_single/#CVsim.wignerify-Union{Tuple{StateVector{B}}, Tuple{B}} where B<:PositionBasis","page":"Single system state","title":"CVsim.wignerify","text":"wignerify(psi)\nwignerify(psi,indices)\n\nCompute the Wigner quasiprobability distribution for the given state vector  (i.e. Ket or Bra). The function just transform the state vector to a density matrix and calculate the distribution.\n\nInputs:\n\npsi::StateVector{B}       : State vector (Ket or Bra) defined in                                the basis B\nindices::Vector{Int}      : Indices of the subspaces for which you                               would like a Wigner quasiprobability\n\nOutput:\n\nif B == PositionBasis:\nMatrix{Float64}         : Wigner quasiprobability of dimension n = length(B)\nif B == CompositeBasis or if indices are specified:\nVector{Matrix{Float64}} : Vector with k Wigner quasiprobability of                             dimension n_k = length(B_k) where B_k                             is the position basis of a subspace of B\n\n\n\n\n\n","category":"method"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use this package, you need to have Julia installed on your system. You can download Julia from the official website: https://julialang.org/","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"CVsim.jl should be available in the Julia General Registry such that its installation can simply be done by","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"   using Pkg; Pkg.add(\"CVsim\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or through the package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open a Julia REPL (Read-Eval-Print Loop) or a Julia IDE.\nChange the directory to the root of the cloned/downloaded repository.\nEnter the package manager by pressing ].\nActivate the package by running the following command:  add CVsim  or alternatively (if you want the latest, potentially unstable, release)  add https://github.com/irojkov-ph/CVsim.jl\nAfter installation, exit the package manager by pressing backspace.","category":"page"},{"location":"preparation/Cat/#prepare_Cat","page":"Cat states","title":"Cat state preparation scripts","text":"","category":"section"},{"location":"preparation/Cat/","page":"Cat states","title":"Cat states","text":"prepare_Cat","category":"page"},{"location":"preparation/Cat/#CVsim.prepare_Cat","page":"Cat states","title":"CVsim.prepare_Cat","text":"prepare_Cat( P; method = \"default\", kwargs...)\n\nPreparation of Schrödinger's Cat states using various methods.\n\nInputs:\n\nP::CVsim_Parameters   : Parameter structure as defined in parameters.jl\nmethod::String        : Method to prepare a Cat state. Currently only \"default\"                            method is implemented. See its definitions bellow.\nkwargs                : Other parameters specific to each method. \n\nOutput:\n\nA Cat state as a Ket state or as an Operator depending on the method (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"preparation/Cat/","page":"Cat states","title":"Cat states","text":"CVsim.default_2Cat_preparation","category":"page"},{"location":"preparation/Cat/#CVsim.default_2Cat_preparation","page":"Cat states","title":"CVsim.default_2Cat_preparation","text":"default_2Cat_preparation( P; α = 1.0+0.0im, logical_basis = false, θ = π/2, ϕ = 0.0)\n\nPreparation of two-component Cat states as a superposition of two gaussians  equally distant from the origin of phase space. The state is defined as\n\n    |Cat⟩ ∝ cos(θ)|0⟩L + exp(iϕ)sin(θ)|1⟩L\n\nInputs:\n\nP::CVsim_Parameters : Parameter structure as defined in parameters.jl\nα::Number           : Amplitude of the coherent states (can be Complex)\nlogical_basis::Bool : Logical basis in which the state is prepared \nset false for defining |0⟩L (|1⟩L) as right (left) coherent states\nset true  for defining |0⟩L (|1⟩L) as even (odd) superposition of coherent states\nθ::Float64          : sin(θ) defines the proportion of |0⟩L and |1⟩L states\nϕ::Float64          : Relative phase between |0⟩L and |1⟩L\n\nOutput:\n\n|Cat⟩ Ket vector (normalized)\n\n\n\n\n\n","category":"function"},{"location":"parameters/#parameters","page":"CVsim Parameters","title":"CVsim Parameters","text":"","category":"section"},{"location":"parameters/","page":"CVsim Parameters","title":"CVsim Parameters","text":"The main object of CVsim.jl is the CVsim_Parameters structure that is used for constructing the CV states and in state preparation and stabilization protocols. It is constructed using the Parameters.jl package and stores all the constants defining a particular simulation. ","category":"page"},{"location":"parameters/","page":"CVsim Parameters","title":"CVsim Parameters","text":"CVsim_Parameters","category":"page"},{"location":"parameters/#CVsim.CVsim_Parameters","page":"CVsim Parameters","title":"CVsim.CVsim_Parameters","text":"CVsim_Parameters( ; qvec_min = -8*√π, qvec_max = 8*√π, n_points = 300, \n                    b_prefered = \"position\", spin_number = 1//2, qudit_levels = 3 )\n\nStructure storing essential parameters that define a given simulation\n\nInputs (optional):\n\nqvec_min::Float64          : Minimum position in phase space.\nqvec_max::Float64          : Maximum position in phase space.\nn_points::Int              : Number of points equidistantly distributed between qvec_min and qvec_max.\nb_prefered::String         :  Preferred basis for state representation (\"position\" or \"momentum\").\nspin_number::Rational{Int} :  Spin number for a spin auxillary system.\nqudit_levels::Int          : Number for qudit levels for a qudit auxillary system.\n\nOutput:\n\nA CVsim_Parameters structure containing these parameters as well as  the essential bases (position, momentum, spin, qudit).\n\n\n\n\n\n","category":"type"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"EditURL = \"../examples/1-state-prep.jl\"","category":"page"},{"location":"examples_md/1-state-prep/#State-preparation-and-visualization","page":"State preparation and visualization","title":"State preparation and visualization","text":"","category":"section"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"This example shows the basic functionality of the CVsim.jl package.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"We start by including the necessary libraries. CVsim.jl can be seen as an extensions of the QuantumOptics.jl package which provides the basic functionality for quantum optics simulations in Julia. CVsim.jl extends this functionality to continuous-variable (CV) system simulations in the position/momentum basis. We then include both packages.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"using QuantumOpticsBase\nusing CVsim","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"note: Note\nHere, we include QuantumOpticsBase.jl as we only require the bare functionalities of the QuantumOptics.jl package. If one needs more advanced features, one can include the full package using QuantumOptics.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"The first step on a CV simulation is to define its parameters. We will use 100 points in the interval -6sqrtpi6sqrtpi for the quadrature variables. The accuracy of the simulation can be adjusted by changing the number of points and the size of the interval.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"# CVsim parameters\nP = CVsim_Parameters(n_points = 100, qvec_min = -6*√π, qvec_max= 6*√π);\nnothing #hide","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"The main quadrature basis accessed using P.b is the position one, but it can be adjusted using the parameter b_prefered (see Parameters). Using this preferred quadrature basis we can define the various operators such as the quadrature operators q and p.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"q = position(P.b);\nnothing #hide","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"Using a quadrature basis as opposed to the Fock basis allows us to define some useful operators such as the displacement operator D(α) in a more convenient way as some of them are diagonal in the position quadrature, e.g.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"using LinearAlgebra\ndisplace_q(α::Real) = Operator(P.b, Diagonal(exp.(1im*α*diag(q.data))));\nnothing #hide","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"The momentum operator in the position basis is defined using","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"p = momentum(P.b);\nnothing #hide","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"However, p is related to q by a Fourier transform, thus we can switch between the the momentum and position bases using the transformation operators P.Tmp and P.Tpm. In the momentum basis, the momentum operator is diagonal, thus allowing the user to improve the efficiency of the simulation when working with momentum operators.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"We can now initialize some CV states such as Cat and GKP states. For this, we only require the functions prepare_Cat and prepare_GKP.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"GKP = prepare_GKP(P; κ = 0.35, Δ = 0.35);\nCat = prepare_Cat(P; α = 2.5,  θ = π/4);\nnothing #hide","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"We would now like to vizualize the position distribution of those states. For this, we include the plotting package Plots.jl as well as the LaTeXStrings.jl package for LaTeX rendering of the labels.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"using Plots\nusing LaTeXStrings","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"We can easily access the position distribution of the states using the squared absolute value of the diagonal of the density matrix (or simply the squared absolute value of the state vector) when defined in the position basis.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"p1 = plot(P.qvec,real.(abs2.(Cat.data)),title=\"Cat\",linewidth=2);\np2 = plot(P.qvec,real.(abs2.(GKP.data)),title=\"GKP\",linewidth=2);\nplot(p1,p2,layout=(1,2),size=(800,300),thickness_scaling=1.5,margin=2Plots.mm,\n    xlabel=L\"q\",ylabel=L\"\\mathbb{P}(q)\",legend=false,framestyle=:box,xlims=(-8,8))","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"The momentum quadrature distribution can be obtained similarly by transforming the state to the momentum basis.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"p1 = plot(P.pvec,real.(abs2.((P.Tmp*Cat).data)),title=\"Cat\",linewidth=2);\np2 = plot(P.pvec,real.(abs2.((P.Tmp*GKP).data)),title=\"GKP\",linewidth=2);\nplot(p1,p2,layout=(1,2),size=(800,300),thickness_scaling=1.5,margin=2Plots.mm,\n    xlabel=L\"p\",ylabel=L\"\\mathbb{P}(p)\",legend=false,framestyle=:box,xlims=(-8,8))","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"Finally, we can also visualize the Wigner quasiprobability of the states by first calculating it using the wignerify function (see Wigner quasiprobability) and then plotting it using the heatmap function from Plots.jl.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"Wig = wignerify(Cat);\nw1  = heatmap(P.qvec,P.pvec,Wig,legend=false,c=cgrad([:red, :white, :blue]),\n              clim=(-maximum(Wig),maximum(Wig)),levels=200,framestyle=:box,\n              aspect_ratio=1,title=\"Cat\");\nyaxis!(L\"p\", (-4,4)); xaxis!(L\"q\", (-4,4));\n\nticks  = [ k*√π for k = -4:2:4 ];\nlabels = [ string(round(k))*L\"\\sqrt{\\pi}\" for k = -4:2:4 ];\nWig = wignerify(GKP);\nw2  = heatmap(P.qvec,P.pvec,Wig,legend=false,c=cgrad([:red, :white, :blue]),\n              clim=(-maximum(Wig),maximum(Wig)),levels=200,framestyle=:box,\n              aspect_ratio=1,title=\"GKP\");\nyaxis!(L\"p\", (ticks[1],ticks[end])); yticks!(ticks,labels);\nxaxis!(L\"q\", (ticks[1],ticks[end])); xticks!(ticks,labels);\n\nplot(w1,w2,layout=(1,2),size=(800,400),thickness_scaling=1.5,margin=2Plots.mm)","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"The resolution of the Wigner function can be adjusted by changing the number of points and the size of the interval in the CVsim_Parameters.","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"","category":"page"},{"location":"examples_md/1-state-prep/","page":"State preparation and visualization","title":"State preparation and visualization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"preparation/GKP/#prepare_GKP","page":"GKP states","title":"GKP state preparation scripts","text":"","category":"section"},{"location":"preparation/GKP/","page":"GKP states","title":"GKP states","text":"prepare_GKP","category":"page"},{"location":"preparation/GKP/#CVsim.prepare_GKP","page":"GKP states","title":"CVsim.prepare_GKP","text":"prepare_GKP( P; method = \"default\", kwargs...)\n\nPreparation of Gottesman-Kitaev-Preskill (GKP) states using various methods.\n\nInputs:\n\nP::CVsim_Parameters   : Parameter structure as defined in parameters.jl\nmethod::String        : Method to prepare a GKP state. Currently only                           \"default\", \"Hastrup\", \"Albert\", \"Mensen\" methods                             are implemented. See their definitions bellow.\nkwargs                : Other parameters specific to each method. \n\nOutput:\n\nA GKP state as a Ket state or as an Operator depending on the method (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"preparation/GKP/","page":"GKP states","title":"GKP states","text":"CVsim.default_GKP_preparation","category":"page"},{"location":"preparation/GKP/#CVsim.default_GKP_preparation","page":"GKP states","title":"CVsim.default_GKP_preparation","text":"default_GKP_preparation( P; μ = 0.0, Δ = 0.37, κ = 0.37, period = 2√π, parity = 0)\n\nPreparation of the approximate GKP state using a sum of gaussians with an outer envelope\n\nInputs:\n\nP::CVsim_Parameters : Parameter structure as defined in parameters.jl\nμ::Float64          : Center of the big gaussian envelope\nΔ::Float64          : Δ² - variance of Gaussian peaks in the GKP state\nκ::Float64          : 1/κ² - variance of the Gaussian envelope\nperiod::Float64     : Period of the θ function, \nset 2√π for |0⟩L and |1⟩L states\nset √π for |+⟩L and |-⟩L states\nparity::Bool        : Boolean that sets the parity of the state\nset 0 for |0⟩L and |+⟩L\nset 1 for |1⟩L and |-⟩L\nn_peaks::Int        : Half of the total number of Gaussian peaks that                         that compose the state\n\nOutput:\n\n|GKP⟩ Ket vector\n\n\n\n\n\n","category":"function"},{"location":"preparation/GKP/","page":"GKP states","title":"GKP states","text":"CVsim.hastrup_preparation","category":"page"},{"location":"preparation/GKP/#CVsim.hastrup_preparation","page":"GKP states","title":"CVsim.hastrup_preparation","text":"hastrup_preparation( P; n_cycles = 2, κ_squeez = .37, σ_ground = 1.0)\n\nPreparation of the approximate GKP state using an additional two-level quantum system and measurement-free preparation protocol as proposed by Hastrup et al. in DOI: 10.1038/s41534-020-00353-3\n\nWarning: The returned state has a spin component. Inputs:\n\nP::CVsim_Parameters  : Parameter structure as defined in parameters.jl\nn_cycles::Int        : Number of cycles of preparation as defined in                           the paper. Suported numbers are 2, 3, 4.\nκ_squeez::Float64    : Squeezing of the initial squeezed vacuum state\nσ_ground::Float64    : Standard deviation of the vacuum state (gaussian state)\n\nOutput:\n\n|0⟩L GKP Ket ⊗ spin Ket\n\n\n\n\n\n","category":"function"},{"location":"preparation/GKP/","page":"GKP states","title":"GKP states","text":"CVsim.albert_preparation","category":"page"},{"location":"preparation/GKP/#CVsim.albert_preparation","page":"GKP states","title":"CVsim.albert_preparation","text":"albert_preparation( P; Δ = 0.37, n_peaks = 51, GKP_1 = false)\n\nPreparation of the approximate GKP state by summing a certain number of displaced squeezed states as reported by Albert et al. in Eq.(7.7a) from DOI: 10.1103/PhysRevA.97.032346 \n\nInputs:\n\nP::CVsim_Parameters   : Parameter structure as defined in parameters.jl\nΔ::Float64            : Δ² - variance of Gaussian peaks in the GKP state,                           and 1/Δ² - variance of the Gaussian envelope\nn_peaks::Int          : Number of peaks to initialize\nGKP_1::Bool           : if set to true |1⟩L will be initialized otherwise |0⟩L\n\nOutput:\n\n|GKP⟩ Ket vector\n\n\n\n\n\n","category":"function"},{"location":"preparation/GKP/","page":"GKP states","title":"GKP states","text":"CVsim.mensen_preparation","category":"page"},{"location":"preparation/GKP/#CVsim.mensen_preparation","page":"GKP states","title":"CVsim.mensen_preparation","text":"mensen_preparation( P; μ = 0.0, Δ = 0.37, κ = 0.37, period = 2√π, logic = [[0],[0]])\n\nPreparation of the approximate GKP state using the Jacobi θ function as as reported by Mensen et al. in Eq.(3.34) from DOI: 10.1103/PhysRevA.104.022408\n\nTo evaluate the Jacobi θ function we use the package  Theta.jl from DOI: 10.2140/jsag.2021.11.41\n\nInputs:\n\nP::CVsim_Parameters        : Parameter structure as defined in parameters.jl\nμ::Float64                 : Center of the big gaussian envelope\nΔ::Float64                 : Δ² - variance of Gaussian peaks in the GKP state\nκ::Float64                 : 1/κ² - variance of the Gaussian envelope\nperiod::Float64            : Period of the θ function, \nset 2√π for |0⟩L and |1⟩L states\nset √π for |+⟩L and |-⟩L states\nlogic::Vector{Vector{Int}} : Vector of two booleans which sets the order of the peaks\nset [[0],[0]] for |0⟩L and |+⟩L\nset [[0],[1]] for |1⟩L\nset [[1],[0]] for |-⟩L\n\nOutput:\n\n|GKP⟩ Ket vector\n\n\n\n\n\n","category":"function"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"EditURL = \"../examples/2-cz-gkp.jl\"","category":"page"},{"location":"examples_md/2-cz-gkp/#CZ-gate-between-two-GKP-states","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"","category":"section"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"This is a more advanced example compared to the previous one as it involves now two bosonic modes which encode two logical qubit. As previously we start by including the necessary libraries.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"using QuantumOpticsBase\nusing CVsim\nusing LinearAlgebra\nusing Plots\nusing LaTeXStrings","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We then define the parameters of our CV simulation. We will use 300 points in the interval -12sqrtpi12sqrtpi for the quadrature variables. We also define the quadrature operators for the two modes as well as some placeholder functions to prepare the states where the last two prepare the maximally entangled (a.k.a. Bell) states.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"# CVsim parameters\nP = CVsim_Parameters(n_points = 300, qvec_min = -12*√π, qvec_max= 12*√π)\nq = position(P.b)\n\n# State preparation functions\nGKP0(κ,Δ) = prepare_GKP(P; κ = κ, Δ = Δ)\nGKP1(κ,Δ) = prepare_GKP(P; κ = κ, Δ = Δ, parity = true)\nGKPp(κ,Δ) = prepare_GKP(P; κ = κ, Δ = Δ, period = √π)\nGKPm(κ,Δ) = prepare_GKP(P; κ = κ, Δ = Δ, period = √π, parity = true)\n\nΦ(κ,Δ,parity) = 1/√2 * ( GKP0(κ,Δ) ⊗ GKP0(κ,Δ) + (-1)^parity * GKP1(κ,Δ) ⊗ GKP1(κ,Δ) )\nΨ(κ,Δ,parity) = 1/√2 * ( GKP0(κ,Δ) ⊗ GKP1(κ,Δ) + (-1)^parity * GKP1(κ,Δ) ⊗ GKP0(κ,Δ) );\nnothing #hide","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"As in the previous example we also define a placeholder function for ploting the Wigner function of the states using Plots.jl.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"# Function which automates Wigner plots\nfunction plot_wigner(state)\n    ticks  = [ k*√π for k = -6:2:6 ];\n    labels = [ string(round(k))*L\"\\sqrt{\\pi}\" for k = -6:2:6 ];\n    Wig = wignerify(state);\n\n    heatmap(P.qvec, P.pvec, Wig, legend=false,\n            c=cgrad([:red, :white, :blue]),\n            clim=(-maximum(Wig),maximum(Wig)),\n            levels=200, framestyle = :box, aspect_ratio=1)\n    yaxis!(\"p\", (ticks[1],ticks[end]))\n    yticks!(ticks,labels)\n    xaxis!(\"q\", (ticks[1],ticks[end]))\n    xticks!(ticks,labels)\n  end;\nnothing #hide","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We would like to implement a logical CZ gate which is a two-qubit gate that flips the sign of the second qubit if the first qubit is in the state vert1rangle. For GKP codes it is know that two-qubit gates correspond to specific quadrature-quadrature operators. In particular, controlled phase gate is defined as","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"      CZ = expleft(-i q_1 q_2 right)","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"where q_1 and q_2 are the quadrature operators of the two modes.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Since CVsim.jl represents quantum states in position/momentum space we can directly implement the above operator since it is diagonal in the position basis","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"CZ(θ::Number) = SparseOperator(P.b ⊗ P.b, Diagonal(exp.(-1im*θ*diag((q ⊗ q).data))));\nnothing #hide","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We allow the operator to be parametrized by an angle theta which would correspond to the application time of the quadrature-quadrature coupling. The actual CZ gate is implemented when theta=1.","category":"page"},{"location":"examples_md/2-cz-gkp/#Truth-table-of-the-CZ-gate","page":"CZ gate between two GKP states","title":"Truth table of the CZ gate","text":"","category":"section"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We now would like to construct the truth table of the logical CZ gate for the GKP states. For this we evaluate the overlap between an input state vertPsi_mathrminrangle and an output state vertPsi_mathrmoutrangle after applying the CZ gate, i.e.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"    O = langlePsi_mathrminvert CZ vertPsi_mathrmoutrangle","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Note that here O does not exactly correspond to the fidelity which would be the squared norm of this overlap. We do this calculation for all the logical computational basis states as input and output states, that we then arrange in a truth table.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"comput_basis(κ,Δ) = [GKP0(κ,Δ)⊗GKP0(κ,Δ), GKP0(κ,Δ)⊗GKP1(κ,Δ), GKP1(κ,Δ)⊗GKP0(κ,Δ), GKP1(κ,Δ)⊗GKP1(κ,Δ)];\nnothing #hide","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We construct such truth tables for GKP states with parameters kappa_1=Delta_1=035 and kappa_2=Delta_2=025.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"κ1=Δ1=0.35\nκ2=Δ2=0.25\n\nbasis1 = comput_basis(κ1,Δ1)\nbasis2 = comput_basis(κ2,Δ2)\n\nTT1 = basis1'.*([CZ(1.0)].*basis1)\nTT2 = basis2'.*([CZ(1.0)].*basis2);\nnothing #hide","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Plotting the truth tables as heatmap with color bar limited to [-1,1], we get the following results","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"gradient=cgrad([:black,:blue,:white,:red,:black], [0.15, 0.5, 0.85]);\n\nh1=heatmap(real(TT1),c=gradient,clim=(-1,1),framestyle=:box,aspect_ratio=1,title=L\"\\kappa_1=\\Delta_1=0.35\");\nannotate!([(j, i, text(round(real(TT1)[i,j],digits=3), 8,\"Computer Modern\",:gray)) for i in 1:4 for j in 1:4]);\n\nh2=heatmap(real(TT2),c=gradient,clim=(-1,1),framestyle=:box,aspect_ratio=1,title=L\"\\kappa_2=\\Delta_2=0.25\");\nannotate!([(j, i, text(round(real(TT2)[i,j],digits=3), 8,\"Computer Modern\",:gray)) for i in 1:4 for j in 1:4]);\n\nplot(h1,h2,layout=(1,2),size=(900,400),thickness_scaling=1.5, margin=2Plots.mm,\n     xlims=(0.5,4.5),xticks = (1:4,[\"|00⟩\",\"|01⟩\",\"|10⟩\",\"|11⟩\"]),\n     ylims=(0.5,4.5),yticks = (1:4,[\"|00⟩\",\"|01⟩\",\"|10⟩\",\"|11⟩\"]))","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"The truth tables show that the CZ gate works as expected for the GKP states. The gate flips the sign of the second qubit if the first qubit is in the state vert1rangle. The gate is also symmetric with respect to the input and output states.","category":"page"},{"location":"examples_md/2-cz-gkp/#Wigner-quasiprobability-before-and-after","page":"CZ gate between two GKP states","title":"Wigner quasiprobability before and after","text":"","category":"section"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"However, the CZ gate is not perfect as the overlap is does not exactly equal to 1. This is due to the fact that the CZ gate is not a perfect two-qubit gate for finite-energy GKP states. To show why we can plot the single mode Wigner quasiprobability of the input and output states of the CZ gate.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Ψ_in  = GKP0(0.3,0.3)⊗GKP0(0.3,0.3)\nΨ_out = CZ(1.0)*Ψ_in\n\nw1=plot_wigner(ptrace(Ψ_in,2),);\nw2=plot_wigner(ptrace(Ψ_out,2));\nplot(w1,w2,layout=(1,2),size=(900,400),\n     thickness_scaling=1.5,margin=2Plots.mm,\n     title=[\"Input state\" \"Output state\"])","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"We observe that the Wigner quasiprobability of the output state is slightly distorted compared to the input state one. This finite-energy effect then affects the overlap between the input and output states of the CZ gate.","category":"page"},{"location":"examples_md/2-cz-gkp/#Physical-fidelity-of-the-CZ-gate","page":"CZ gate between two GKP states","title":"Physical fidelity of the CZ gate","text":"","category":"section"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Moreover, we see from the truth tables that this overlap differs for different energy envelopes of the GKP states, thus the physical fidelity of the gate. We study this effect in more detail in the next example where we evaluate the fidelity of the CZ gate for different energy envelopes of the GKP states.","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"Δvec = [0.15:0.01:0.4;]\nstates = [GKP0(Δ,Δ)⊗GKP0(Δ,Δ) for Δ in Δvec]\nfidelity = abs2.(diag(states'.*([CZ(1.0)].*states)))\n\nscatter(Δvec,fidelity,size=(700,300),legend=false,framestyle=:box,\n        thickness_scaling=1.5,margin=2Plots.mm,yaxis=((0.6,0.7),0.6:0.02:0.7),\n        xlabel=L\"\\Delta\",ylabel=\"Fidelity\")","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"The plot shows that the fidelity of the CZ gate converges to the finite value of 0.64 for the GKP states with Deltall1. The reasons for these effects and the solutions to counteract them are discussed in more detail in Ref.[1].","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"[1]: I. Rojkov, P. M. Röggla, M. Wagener, M. Fontboté-Schmidt, S. Welte, J. Home, F. Reiter, arXiv:quantum-ph/2305.05262 (2023).","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"","category":"page"},{"location":"examples_md/2-cz-gkp/","page":"CZ gate between two GKP states","title":"CZ gate between two GKP states","text":"This page was generated using Literate.jl.","category":"page"},{"location":"preparation/general/#prepare_general","page":"General structure","title":"General structure of state preparation scripts","text":"","category":"section"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"CVsim.jl was designed for the simulation of continuous variable systems in quadrature space with a particular emphasize on the simulation of bosonic encodings. The two primary classes of bosonic codes are translation-symmetric codes and rotation-symmetric codes[1], exemplified by Gottesman-Kitaev-Preskill (GKP)[2] and Schrödinger's Cat[3][4] codes, respectively.","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"The goal of the state preparation scripts is to implement various state preparation protocols for these codes. Some of the state preparation schemes have been experimentally implemented while others are only theoretical (meaning that they are in general not accessible in experiments). So far, mostly preparation scripts for GKP states have been written. Cat state preparation includes only the default preparation. It would be interesting to implement additional schemes for those codes as well as other fancy continuous-variable states such as binomial codewords, cubic phase state and other non-Gaussian states.","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"The general structure of the state preparation scripts is the following: The filename of the script must be prepare_NAME.jl with NAME denoting the states that are meant to be prepared with this script. The main method definition must then be","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"  prepare_NAME(P::CVsim_Parameters; method::String = \"default\", kwargs...)","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"That means the main method must take exactly one parameter P corresponding to the parameters of a given continuous variable simulation (see CVsim Parameters). The optional variable method then allows the user to select the state preparation scheme/protocol that they desire and kwargs correspond to some additional parameters that this scheme requires.","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"info: Info\nFeel free to contribute in adding novel schemes following this general structure. If you think there could be a better way to implement this in Julia feel free to propose it (we are not experts in Julia). In both cases, please open a pull request with your proposed additions/modifications.","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"[1]: A. L. Grimsmo, J. Combes, and B. Q. Baragiola, Phys. Rev. X 10, 011058 (2020)","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"[2]: D. Gottesman, A. Kitaev, and J. Preskill, Phys. Rev. A 64, 012310 (2001)","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"[3]: P. T. Cochrane, G. J. Milburn, and W. J. Munro, Phys. Rev. A 59, 2631 (1999)","category":"page"},{"location":"preparation/general/","page":"General structure","title":"General structure","text":"[4]: M. Mirrahimi et al., New J. Phys. 16, 045014 (2014)","category":"page"},{"location":"wigner/wigner_joint/#wigner_joint","page":"Joint system state","title":"Wigner quasiprobability of joint CV systems state","text":"","category":"section"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"The Wigner quasiprobability representation of a state rho of a N-mode system (i.e. many continuous-variable systems) is defined as[1][2]","category":"page"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"  W(mathbfx)=frac1(2pi)^2Nint_mathbbR^2N \n  expleft(-imathbfx^mathrmTOmegaxiright) \n  mathrmTrleft rhoexpleft(imathbfhatx^mathrmTOmegaxiright) right \n  mathrmd^2Nmathbfxi ","category":"page"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"where mathbfx and mathbfxi are vectors comprising real values of the 2N quadratures, while mathbfhatx is a vector encompassing the quadrature operators themselves. Here, mathbfOmega corresponds to the symplectic form. The exponential term inside the trace can be rewritten in terms of displacement operators on the 2N modes. Thus, similar method as for the single mode presented in Single system state but has not been implemented in CVsim.jl, yet. Such quasiprobability distribution could be helpful for the diagnostic of entanglement between multiple mode as it has been demonstrated in the context of logical two-qubit gate between bosonic codewords[3].","category":"page"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"[1]: K. E. Cahill and R. J. Glauber, Phys. Rev. 177, 1882 (1969)","category":"page"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"[2]: C. Weedbrook et al. Rev. Mod. Phys. 84, 621 (2012)","category":"page"},{"location":"wigner/wigner_joint/","page":"Joint system state","title":"Joint system state","text":"[3]: C. Wang et al. Science 352, 6289, 1087-1091 (2016)","category":"page"},{"location":"stabilization/GKP/#stabilize_GKP","page":"GKP states","title":"GKP state stabilization scripts","text":"","category":"section"},{"location":"stabilization/GKP/","page":"GKP states","title":"GKP states","text":"stabilize_GKP\nCVsim.DeNeeve_stabilization\nCVsim.CampagneIbarcq_stabilization\nCVsim.Royer_stabilization\nCVsim.Sivak_stabilization","category":"page"},{"location":"stabilization/GKP/#CVsim.stabilize_GKP","page":"GKP states","title":"CVsim.stabilize_GKP","text":"stabilize_GKP( rho, P; method = \"DeNeeve\", kwargs...)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) states using various methods\n\nInputs:\n\nrho::Operator{B,B}    Operator (density matrix) defined in the basis B \nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nmethod::String        Method to prepare a GKP state.                       Default: \"DeNeeve\"\nkwargs                Other parameters specific to each method. \n\nOutput:\n\nA GKP state as an Operator (density matrix)\n\n\n\n\n\nstabilize_GKP( psi, P; method = \"DeNeeve\", kwargs...)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) states using various methods (for now only De Neeve's method is available).\n\nInputs:\n\npsi::StateVector{B}   State vector (Ket or Bra) defined in the basis B\nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nmethod::String        Method to prepare a GKP state.                       Default: \"DeNeeve\" \nkwargs                Other parameters specific to each method. \n\nOutput:\n\nA GKP state as an Operator (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"stabilization/GKP/#CVsim.DeNeeve_stabilization","page":"GKP states","title":"CVsim.DeNeeve_stabilization","text":"DeNeeve_stabilization( rho, P; n_times = 1, ε = 2√π*0.045, α = √π, μ = 2√π*0.065, option = \"\", indices = 0, kraus = true)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) using the spin degree of freedom of an ion as reported by De Neeve et al. in DOI: 10.1038/s41567-021-01487-7\n\nInputs:\n\nrho::Operator{B,B}    Operator (density matrix) defined in the                        position/momentum basis B or a composite basis                       B with at least one position/momentum basis in it. \nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nn_times::Int          Number of stabilization rounds\nε, α, μ ::Float       Three parametres as defined in the paper\noption::String        String specifying which can contain \"q\" or \"p\"                        for correcting only one of the quadratures.                        If none, both will be stabilized. \nindices               Index or vector of indices of subspaces that one                        would like to stabilize. If index = 0, then all                        the relevant subspaces will be subjected to n_cycles                        stabilization.\nkraus::Bool           Use Kraus operators instead of the unitaries and the                       spin degree of freedom. Default: true.\n\nOutput:\n\nA GKP state as an Operator (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"stabilization/GKP/#CVsim.CampagneIbarcq_stabilization","page":"GKP states","title":"CVsim.CampagneIbarcq_stabilization","text":"CampagneIbarcq_stabilization( rho, P; n_times = 1, l = 2√π, Δ = 0.37, option=\"all\", indices = 0)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) using an auxillary transmon and consisting of a sharpening and trimming steps for each  quadrature as reported by Campagne-Ibarcq et al. in DOI: 10.1038/s41586-020-2603-3\n\nInputs:\n\nrho::Operator{B,B}    Operator (density matrix) defined in the                        position/momentum basis B or a composite basis                       B with at least one position/momentum basis in it. \nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nn_times::Int          Number of stabilization rounds\nl::Float              Lattice constant of a square lattice encoding\nΔ::Float              Δ² - variance of Gaussian peaks in the GKP state                       1/Δ² - variance of the Gaussian envelope\noption::String        String specifying which steps to execute:                           \"qS\"     - only sharpening of q-quadrature                           \"qST\"    - sharpening-trimming of q only                       Default: \"all\" which is equivallent to \"qpST\"\nindices               Index or vector of indices of subspaces that one                        would like to stabilize. If index = 0, then all                        the relevant subspaces will be subjected to n_cycles                        stabilization.\n\nOutput:\n\nA GKP state as an Operator (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"stabilization/GKP/#CVsim.Royer_stabilization","page":"GKP states","title":"CVsim.Royer_stabilization","text":"Royer_stabilization( rho, P; n_times = 1, l = 2√π, Δ = 0.37, option=\"sBs\", indices = 0)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) using an auxillary qubit and either of the two methods Big-small-Big or small-Big-small as reported by Royer et al. in Eqs. (6b) and (6c), respectively, from DOI: 10.1038/s41586-020-2603-3\n\nInputs:\n\nrho::Operator{B,B}    Operator (density matrix) defined in the                        position/momentum basis B or a composite basis                       B with at least one position/momentum basis in it. \nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nn_times::Int          Number of stabilization rounds\nl::Float              Lattice constant of a square lattice encoding\nΔ::Float              Δ² - variance of Gaussian peaks in the GKP state                       1/Δ² - variance of the Gaussian envelope\noption::String        String specifying which method to use:                         \"BsB\" - Big-small-Big (work well for Δ ≤ 0.25)                         \"sBs\" - small-Big-small (work better in general)                       The option can also contain \"q\" or \"p\" for correcting                       only one of the quadratures. If none, both will be                       stabilized.                       Default: \"sBs\"\nindices               Index or vector of indices of subspaces that one                        would like to stabilize. If index = 0, then all                        the relevant subspaces will be subjected to n_cycles                        stabilization.\n\nOutput:\n\nA GKP state as an Operator (density matrix)\n\n\n\n\n\n","category":"function"},{"location":"stabilization/GKP/#CVsim.Sivak_stabilization","page":"GKP states","title":"CVsim.Sivak_stabilization","text":"Sivak_stabilization( rho, P; n_times = 1, l = 2√π, Δ = 0.37, option=\"sBs\", indices = 0)\n\nStabilization of Gottesman-Kitaev-Preskill (GKP) code using the same  methods as in Royer et al. (2020) and De Neeve et al. (2022) but to  the exception that here the stabilizer measurement outcomes are not  discarded but recorded. The simulation is thus a state vector simulation which outputs the bosonic state as a state vector and the measurement outcome. DOI: 10.1038/s41586-023-05782-6\n\nInputs:\n\nrho::Ket{B}           State vector defined in the position/momentum                        basis B or a composite basis B with at least                        one position/momentum basis in it. \nP::CVsim_Parameters   Parameter structure as defined in parameters.jl\nn_times::Int          Number of stabilization rounds\nε, α, μ ::Float       Three parametres as defined DeNeeve_stabilization\noption::String        String specifying which can contain \"q\" or \"p\"                        for correcting only one of the quadratures.                        If none, both will be stabilized. \nindices               Index or vector of indices of subspaces that one                        would like to stabilize. If index = 0, then all                        the relevant subspaces will be subjected to n_cycles                        stabilization.\nkraus::Bool           Use Kraus operators instead of the unitaries and the                       spin degree of freedom. Default: true.\n\nOutput:\n\nA GKP state as a state vector (Ket)\nOutcomes of the stabilizer measurement (Bool)\n\n\n\n\n\n","category":"function"},{"location":"#CVsim.jl:-Continuous-variable-quantum-system-simulation-package","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"","category":"section"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"CVsim.jl is a Julia package for simulating continuous variable (CV) quantum systems, with a focus on studying quantum information processing using bosonic codes such as Gottesman-Kitaev-Preskill (GKP), Cat or Binomial states. Unlike traditional approaches that employ the Fock basis representation of states, this package utilizes the first quantization method, specifically sampling the position or momentum quadratures.","category":"page"},{"location":"#Features","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"Features","text":"","category":"section"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"The package allows you to setup the settings of a CV as well as of an auxiliary discrete variable (qubit or qudit) quantum systems, prepare and stabilize some CV codewords using different methods proposed and/or demonstrated in the last decades, and calculate the Wigner quasiprobability distribution of these states. All these elements are presented in detail in the corresponding sections of the documentation.","category":"page"},{"location":"#Current-limitations","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"Current limitations","text":"","category":"section"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"So far mainly the preparation and stabilization of GKP states have been implemented, but we believe that representing other continuous variable states in the position or momentum bases can help in some cases alleviate the computational complexity associated with using the Fock basis. ","category":"page"},{"location":"#Potential-improvements","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"Potential improvements","text":"","category":"section"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"We believe that using position and momentum representations of quantum states and operators can be provide an efficient way to simulate CV system compared of more standard strategies (especially because of the Fourier transform relation between the two bases). We are currently not planning any publication regarding the performance of CVsim.jl. However, if you like the package, please contact us, we will be happy to collaborate!","category":"page"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"If you are working with CV encodings, we will be happy of your contributions to the package. Here are some potential improvements that could be envisaged:","category":"page"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"State preparation and stabilization schemes for Cat and Binomial qubits, e.g. Mirrahimi et al. (2014) and Lihm et al. (2018),\nAdditional state preparation and stabilization schemes for GKP qubits, especially those developed for photonic platforms such as Glancy and Knill (2006) and Walshe et al. (2020),\nLogical operations and particularly the bias preserving gates for Cat qubits, see Puri et al. (2020),\nExperimentally realistic readout protocols for CV state, e.g. Rosenblum, Reinhold et al. (2018) for Cat qubits and Hastrup and Andersen (2021) for GKP codes,\nJoint (i.e. two-mode) Wigner function quasiprobability function calculation, see Wang et al. (2016),\nCharacteristic function calculation,\nDominant noise processes for continuous and discrete variable systems,\nProper compatibility with Float32,\nUnit tests for the package.","category":"page"},{"location":"#Citing","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"Citing","text":"","category":"section"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"This package was developed and employed for the first time for studying gates between two finite-energy GKP states (see Rojkov et al. (2023)). If you use this package in the context of a potential publication we would be pleased if you cite our work as well as the package itself using the following bibtex entries","category":"page"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"  @article{two_qubit_rojkov_2023,\n    title     = {Two-qubit operations for finite-energy Gottesman-Kitaev-Preskill encodings}, \n    author    = {Ivan Rojkov and Paul Moser R\\\"{o}ggla and Martin Wagener and Moritz Fontbot\\'{e}-Schmidt and Stephan Welte and Jonathan Home and Florentin Reiter},\n    journal   = {arXiv:quant-ph/2305.05262},\n    year      = {2023},\n    month     = may,\n  }","category":"page"},{"location":"","page":"CVsim.jl: Continuous variable quantum system simulation package","title":"CVsim.jl: Continuous variable quantum system simulation package","text":"  @software{cvsim_rojkov_2024,\n    author    = {Rojkov, Ivan},\n    title     = {CVsim.jl: Continuous variable quantum system simulation package},\n    month     = jul,\n    year      = 2024,\n    publisher = {Zenodo},\n    version   = {v0.1.0},\n    doi       = {10.5281/zenodo.13127577},\n    url       = {https://doi.org/10.5281/zenodo.13127577}\n  }","category":"page"},{"location":"stabilization/general/#stabilize_general","page":"General structure","title":"General structure of state stabilization scripts","text":"","category":"section"},{"location":"stabilization/general/","page":"General structure","title":"General structure","text":"CVsim.jl was designed for the simulation of continuous variable systems in quadrature space with a particular emphasize on the simulation of bosonic encodings. The goal of the state stabilization scripts is to implement various stabilization protocols for bosonic codes. Some of the stabilization schemes have been experimentally implemented while others are only theoretical. We focussed so far only on measurement-free stabilization protocols for GKP states. Moreover, the implemented schemes are not continuous in time and correspond in practice to a sequence of pulses/gates. It would be interesting to implement additional dissipative discrete/continuous stabilization schemes as well as measurement-based error-correction protocols for GKP codes and other rotation/translation-symmetric bosonic encodings such as Cat and binomial codes. Multi-mode codes are also in principle implementable in CVsim.jl. For a detailed overview of various existing bosonic codes we recommend to have a look at the Error Correction Zoo.","category":"page"},{"location":"stabilization/general/","page":"General structure","title":"General structure","text":"The general structure of the state preparation scripts is the following: The filename of the script must be stabilize_NAME.jl with NAME denoting the states that are meant to be stabilized with this script. The two main method definitions must then be","category":"page"},{"location":"stabilization/general/","page":"General structure","title":"General structure","text":"  stabilize_NAME(rho::Operator, P::CVsim_Parameters; method::String = \"default\", kwargs...)\n  stabilize_NAME(psi::StateVector, P::CVsim_Parameters; method::String = \"default\", kwargs...)","category":"page"},{"location":"stabilization/general/","page":"General structure","title":"General structure","text":"Unlike the state stabilization scripts, here the main method must take exactly two arguments: First, the input state of type StateVector (i.e. Ket or Bra) or Operator (i.e. a density matrix); second, P corresponding to the parameters of a given continuous variable simulation (see CVsim Parameters). The optional variable method then allows the user to select the stabilization scheme/protocol that they desire and kwargs correspond to some additional parameters that this scheme requires.","category":"page"},{"location":"stabilization/general/","page":"General structure","title":"General structure","text":"info: Info\nFeel free to contribute in adding novel stabilization protocols following this general structure. If you think there could be a better way to implement this in Julia feel free to propose it (we are not experts in Julia). In both cases, please open a pull request with your proposed additions/modifications.","category":"page"}]
}
